-- instructions.lua
-- Generates source code from src/instructions into include/gameboy/operations.h

-- trim the line from comments and whitespace
function trimline(line)
	line = string.gsub(line, "#.*", "") -- remove comments
	line = line:match'^()%s*$' and '' or line:match'^%s*(.*%S)'
	return line
end

-- create the function name
function fname(i, p)
	if string.match(p, "-/-") then
		suffix = ""
	else
		suffix = string.gsub(p, "[,%(%)]", "_") .. "__"
	end
	return string.format("__%s__%s", i:lower(), suffix)
end

function clean_params(params)
	return string.gsub(params, "[%(%)-/-]", "")
end

function call_ld(instruction, params)
	c = ""
	-- (n) : $FF00 | RAM (pc ++)
	if string.match(params, "%(n%)") then
		c = "uint16_t n = 0xFF00 | RAM (pc ++); "
	-- (r) : $FF00 | r
	elseif string.match(params, "%(%a%)") then
		c = "uint16_t nn = 0xFF00 | C; "
		params = string.gsub(params, "(%(%a%))", "(nn)")
	-- (nn)/nn : RAM (pc ++) | (RAM (pc ++) << 8)
	elseif string.match(params, "nn") then
		c = "uint16_t nn = RAM (pc ++); nn |= (RAM (pc ++) << 8); "
	-- n : RAM (pc ++)
	elseif string.match(params, "n") then
		c = "uint8_t n = RAM (pc ++); "
	end

	-- if source is in memory we need to make a RAM call
	if string.match(params, ",%(%a%a?%)$") then
		params = params:gsub("(.+),(%(%a%a?%))", "%1,RAM %2")
	--elseif string.match(params, ",%(%a%)$") then
		--params = params:gsub("(.+),(%(%a)%))", "%1,RAM(0xFF00 | %2)")
	end

	-- storing to memory or not
	if string.match(params, "^%(%a%a?%),") then
		c = c .. string.format("STORE (%s);", params)
	else
		c = c .. string.gsub(params, "(.+),(.+)", "%1 = %2;")
	end

	-- LDI and LDD special cases
	if string.match(instruction, "LDI") then
		c = c .. " HL ++;"
	elseif string.match(instruction, "LDD") then
		c = c .. " HL --;"
	end

	return c
end

-- the inner code for the function
function call(instruction, params)
	-- LD is handled differently
	if instruction:match"LD[DI]?$" then
		return call_ld (instruction, params)
	end

	-- POP AF is another special case that needs to always unset last 3 bits of F
	if instruction == "POP" and params == "AF" then
		return "pop (&AF); F &= 0xF0;"
	end

	prefix = ""
	-- if the instruction reads immediate bytes we need to preprend this to the call
	if params:match",?nn?$" then
		if params:match"nn" then
			prefix = "uint16_t nn = RAM (pc ++); nn |= (RAM (pc ++) << 8); "
		elseif params:match"n" then
			prefix = "uint8_t n = RAM (pc ++); "
		end
	end

	-- these instructions take pointers
	local pointerparams = {
		["POP"] = true,
		["DEC"] = true,
		["INC"] = true,
		["DEC16"] = true,
		["INC16"] = true,
		["SWAP"] = true,
		["LD"] = true,
		["LDI"] = true,
		["LDD"] = true,
		["SRL"] = true,
		["SLA"] = true,
		["SRA"] = true,
		["RR"] = true,
		["RL"] = true,
		["RLC"] = true,
		["RRC"] = true,
		["SET"] = true,
		["RES"] = true,
	}

	-- special case when it is pointer parameters using (HL) as destination which stores to mem
	if pointerparams[instruction] and params:match"^%(HL%)" then
		params = params:gsub("^(%(HL%))", "&n")
		return string.format("uint8_t n = RAM (HL); %s (%s); STORE (HL, n);", instruction:lower(), params)
	end

	if params:match"%(HL%)" then
		params = params:gsub("(%(HL%))", "RAM (HL)")
	else
		params = clean_params(params)
	end

	if pointerparams[instruction] then
		params = "&" .. params
	end
	return prefix .. string.format("%s (%s);", instruction:lower(), params);
end

local operations_CB = {}
local operations = {}

-- turn the information in one line to an instruction
function operation(line)
	-- parse the line for the different tokens
	local tokens = {}
	for w in string.gmatch(line, '%S+') do tokens[#tokens+1] = w end

	local it = tokens[1]
	local pm = tokens[2]
	local op = tokens[3]
	local cc = tokens[4]
	local fn = fname(it, pm)

	op_map = operations

	if op:match"^CB" then
		op = op:gsub("CB(..)", "%1")
		op_map = operations_CB
	end

	op = tonumber("0x" .. op)
	op_map[op] =  {
		["inst"] = it,
		["asm"] = string.format("%s %s", it, pm),
		["str"] = string.format("void %s () { %s }", fn, call(it, pm)),
		["cc"] = tonumber(cc),
		["fn"] = fn,
	}

	return op_map[op]["str"]
end

-----------------------------------------------------------------------------------------------------
-- Main script

-- open our output file
file = io.open("include/gameboy/operations.h", "w")
io.output(file)

-- write a comment about the file
io.write([[/**
* operations.h: contains all the CPU operations mapped by opcode.
* This file has been autogenerated by using `lua instructions.lua`.
*/

#ifndef GB_CPU_OPERATIONS_H
#define GB_CPU_OPERATIONS_H

#include <stdio.h>

typedef
struct operation
{
	// name is the debugging name of the operation.
	const char* name;

	// the instruction to be executed
	const void (*instruction)();

	// number of bytes the operation consumes
	const uint8_t b;

	// number of cycles the operation needs.
	// in some cases there might be more in the case of e.g. branching.
	const uint8_t cc;
}
operation;

]])

-- not all possible opcodes are mapped to an operation.
-- we fill therefore with an invalid operation at each opcode and then re-assign
-- as we parse the file.
-- The CBxx all make exactly 256 operations so no need there.

io.write("void invalid_op() { fprintf (stderr, \"INVALID OPERATION\\n\"); }", "\n")

local invalid_instruction = {
	["inst"] = "INVALID",
	["asm"] = "INVALID",
	["str"] = "",
	["cc"] = 0,
	["fn"] = "invalid_op",
}

for i = 0, 255, 1 do
	operations[i] = invalid_instruction
end

-- iterate over all lines in the file and create an instruction for each
for line in io.lines("src/instructions") do
	line = trimline(line)
	if line ~= "" then io.write(operation(line), "\n") end
end

-- create CBxx operations
io.write("\nconst operation operations_cb[256] = {\n")
for op = 0, 255, 1 do
	io.write(string.format("// %.2X: %s\n", op, operations_CB[op]["asm"]))
	io.write(string.format(
		"{ \"%s\", &%s, 0, %d },\n",
		operations_CB[op]["asm"],
		operations_CB[op]["fn"],
		operations_CB[op]["cc"]
	))
end
io.write("};\n")

-- create the special CB instruction that runs instruction from the `operations_cb` map
io.write("void __cbxx__() { uint8_t op = RAM (pc ++); operations_cb[op].instruction(); }\n")
operations[0xCB] = {
	["inst"] = "CBXX",
	["asm"] = "-- CBXX --",
	["str"] = "",
	["fn"] = "__cbxx__",
	["cc"] = 8, -- TODO this is not always true!!
}

-- all 8-bit instructions
io.write("\nconst operation operations[256] = {\n")
for op = 0, 255, 1 do
	io.write(string.format("// %.2X: %s\n", op, operations[op]["asm"]))
	io.write(string.format(
		"{ \"%s\", &%s, 0, %d },\n",
		operations[op]["asm"],
		operations[op]["fn"],
		operations[op]["cc"]
	))
end
io.write("};\n")

io.write("#endif\n")

io.close(file)
