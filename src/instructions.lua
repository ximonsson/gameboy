-- instructions.lua

print("Generating source for Game Boy CPU instructions\n")

-- trim the line from comments and whitespace
function trimline(line)
	line = string.gsub(line, "#.*", "") -- remove comments
	line = line:match'^()%s*$' and '' or line:match'^%s*(.*%S)'
	return line
end

-- generate code for the parsed parameters
function params(p)
	-- special cases
	direct = {
		["(n)"] = "RAM(0xFF00 | RAM(pc ++))",
		["(nn)"] = "RAM((RAM(pc ++) << 8) | RAM(pc ++))",
		["n"] = "RAM(pc ++)",
		["nn"] = "((RAM(pc ++) << 8) | RAM(pc ++))",
		["-/-"] = "",
	}

	function param(p)
		if direct[p] ~= nil then
			return direct[p]
		elseif string.match(p, "%(.+%)") then -- (rr)
			return "RAM(" .. string.match(p, "%((.+)%)") .. ")"
		else -- r
			return p
		end
	end

	return string.gsub(p, "([^,]+)", param)
end

-- create the function name
function fname(i, p)
	if string.match(p, "-/-") then
		suffix = ""
	else
		suffix = string.gsub(p, "[,%(%)]", "_")
	end
	return string.format("__%s__%s__", i, suffix)
end

-- special CBxx operations
function CB(tokens)
	--	print(tokens[3], ": unsupported for now")
	return ""
end

-- LD instructions are a little special because they store the result to RAM
-- some times
function LD(it, params)
	if string.match(params, "%(nn%),A") then
		return "uint16_t nn = RAM(pc++) | (RAM(pc++) << 8); STORE(nn, A);"
	elseif string.match(params, "%(n%),A") then
		return "uint16_t nn = 0xFF00 | RAM(pc++); STORE(nn, A);"
	elseif string.match(params, "%(nn%),SP") then
		return "uint16_t nn = RAM(pc++) | (RAM(pc++) << 8); STORE(nn, SP); STORE(nn+1, SP >> 8);"
	end
	return ""
end

local operations = {}
local opcodes = {}

function opstr()

end

-- turn the information in one line to an instruction
function operation(line)
	-- parse the line for the different tokens
	local tokens = {}
	for w in string.gmatch(line, '%S+') do tokens[#tokens+1] = w end

	-- work each token accordingly
	local it = string.lower(tokens[1])
	local pm = tokens[2]
	local op = tokens[3]
	local cc = tokens[4]

	local p = params(pm)

	-- some instructions need some special handling

	local pointerparams = {
		["pop"] = true,
		["dec"] = true,
		["inc"] = true,
		["dec16"] = true,
		["inc16"] = true,
		["swap"] = true,
		["ld"] = true,
		["ldi"] = true,
		["ldd"] = true,
	}

	-- CBxx operations are special
	if string.match(op, "CB%w%w") then
		return CB(tokens)
	-- some instructions take pointers as parameters
	elseif pointerparams[it] then
		p = "&" .. p
	end

	local fn = fname(it, pm)
	local opcode = tonumber("0x" .. op)

	-- standard format for the function
	local opfmt = "void %s() { %s };"

	-- handle LD to memory differently
	if string.match(it, "ld") and string.match(pm, "%(%w%w?%),") then
		inner = LD(it, pm)
	else
		inner = string.format("%s(%s);", it, p)
	end

	opcodes[#opcodes + 1] = opcode
	operations[opcode] =  {
		["inst"] = it:upper(),
		["asm"] = string.format("%s %s", it:upper(), pm),
		["str"] = string.format(opfmt, fn, inner),
		["cc"] = tonumber(cc),
		["fn"] = fn,
	}

	return operations[opcode]["str"]
end

-----------------------------------------------------------------------------------------------------
-- Main script

-- open our output file
file = io.open("include/gameboy/operations.h", "w")
io.output(file)

-- write a comment about the file
io.write([[/**
* operations.h: contains all the CPU operations mapped by opcode.
* This file has been autogenerated by using `lua instructions.lua`.
*/

#ifndef GB_CPU_OPERATIONS_H
#define GB_CPU_OPERATIONS_H

typedef
struct operation
{
	// name is the debugging name of the operation.
	const char* name;

	// the instruction to be executed
	const void (*instruction)();

	// number of bytes the operation consumes
	const uint8_t b;

	// number of cycles the operation needs.
	// in some cases there might be more in the case of e.g. branching.
	const uint8_t cc;
}
operation;

]])

-- iterate over all lines in the file and create an instruction for each
for line in io.lines("src/instructions") do
	line = trimline(line)
	if line ~= "" then
		io.write(operation(line), "\n")
	end
end

io.write("const operation operations[0xFF] = {\n")
table.sort(opcodes)
for _, op in pairs(opcodes) do
	io.write(string.format("// %.2X: %s\n", op, operations[op]["asm"]))
	io.write(string.format(
		"{ \"%s\", &%s, 0, %d },\n",
		operations[op]["asm"],
		operations[op]["fn"],
		operations[op]["cc"]
	))
end
io.write("};\n")

io.write("#endif")

io.close(file)
